apply plugin: 'maven'

repositories {
    maven { url "https://raw.github.com/synergian/wagon-git/releases" }
}

configurations {
    deployToGitHub
    deployToArchiva
}

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])

    deployToGitHub "ar.com.synergian:wagon-git:0.3.0"

    deployToArchiva "org.apache.maven.wagon:wagon-http:2.2"
}

task androidJavadocs(type: Javadoc) {
    failOnError false
    source = android.sourceSets.main.java.sourceFiles
}

task androidSourcesJar(type: Jar) {
    classifier = 'sources'
    from android.sourceSets.main.java.sourceFiles
}

task androidJavadocsJar(type: Jar, dependsOn: androidJavadocs) {
    classifier = 'javadoc'
    from androidJavadocs.destinationDir
}

artifacts {
    archives androidJavadocsJar
}

task lookForArtifacts {
    doLast {
        if(REPOSITORY_NAME == 'GITHUB'){
            def repositoryUrl = 'https://api.github.com/repos/' + COMPANY + '/' + REPOSITORY_PROJECT + '/releases/tags/' + ARTIFACT_VERSION
            if (urlExists(repositoryUrl)) {
                throw new RuntimeException("Artifact with version " + ARTIFACT_VERSION + " already exist - not executing uploadArchives")
            }
        }
        return true
    }
}

task publish(dependsOn: ['uploadArchives', 'tagRelease'])

uploadArchives {
    repositories.mavenDeployer {
        if(REPOSITORY_NAME == 'ARCHIVA'){
            configuration = configurations.deployToArchiva
            repository(url: "http://repo.corp.vibes.com/archiva/repository/internal/") {
                authentication(userName: "$System.env.VIBES_ARCHIVA_USERNAME", password: "$System.env.VIBES_ARCHIVA_PASSWORD")
            }
        }else if(REPOSITORY_NAME == 'GITHUB'){
            configuration = configurations.deployToGitHub
            repository(url: 'git:releases://git@github.com:' + COMPANY + '/' + REPOSITORY_PROJECT + '.git')
        }

        uniqueVersion = true

        pom.project {
            groupId = ARTIFACT_PACKAGE
            version = ARTIFACT_VERSION
            artifactId = ARTIFACT_NAME
            packaging ARTIFACT_PACKAGING
        }
    }
}
uploadArchives.dependsOn lookForArtifacts

task tagRelease << {
    if(REPOSITORY_NAME == 'GITHUB'){
        def url = 'https://api.github.com/repos/' + COMPANY + '/' + REPOSITORY_PROJECT + '/releases'
        try {
            def connection = (HttpURLConnection) new URL(url).openConnection()

            connection.setRequestProperty("Authorization", "Basic " + getBase64EncodedCredentials())
            connection.setRequestProperty("Accept", "application/vnd.github.v3+json")
            connection.setConnectTimeout(10000)
            connection.setReadTimeout(10000)
            connection.setRequestMethod("POST")
            connection.doOutput = true

            def writer = new OutputStreamWriter(connection.outputStream)
            def json = '{ "tag_name": "' + ARTIFACT_VERSION + '", "target_commitish": "releases" }'
            writer.write(json)
            writer.flush()
            writer.close()

            def responseCode = connection.getResponseCode()

            if (responseCode != 201) {
                throw new RuntimeException("Could not tag release, response was: " + responseCode)
            }

            return (201 == responseCode)
        } catch (IOException exception) {
            throw new RuntimeException("Could not tag release: " + exception.toString())
        }
    }
}
tagRelease.mustRunAfter uploadArchives

def urlExists(String repositoryUrl) {
    try {
        def connection = (HttpURLConnection) new URL(repositoryUrl).openConnection()

        connection.setRequestProperty("Authorization", "Basic " + getBase64EncodedCredentials())
        connection.setRequestProperty("Accept", "application/vnd.github.v3+json")
        connection.setConnectTimeout(10000)
        connection.setReadTimeout(10000)
        connection.setRequestMethod("HEAD")

        def responseCode = connection.getResponseCode()

        if (responseCode == 401) {
          throw new RuntimeException("Unauthorized user - please provide valid username and token in gradle.properties file")
        }

        return (200 == responseCode)
    } catch (IOException ignored) {
        return false
    }
}

def getBase64EncodedCredentials() {
    def github_username = "$System.env.VIBES_GITHUB_USERNAME"
    def github_password = "$System.env.VIBES_GITHUB_PASSWORD"
    def auth = github_username + ":" + github_password
    def encodedAuth = auth.bytes.encodeBase64().toString()
    return encodedAuth
}
